# 位运算

本文主要记录一下关于位运算的一些内容。 更多 hacking 技巧 refer: [Bit Twiddling Hacks](http://graphics.stanford.edu/~seander/bithacks.html)

## 一些基本的位运算操作

> reference: [Matrix67](http://www.matrix67.com/blog/archives/263)

|功能|示例|位运算|
|:-:|:-:|:-:|
|去掉最后一位          | (101101->10110)           | x shr 1|
|在最后加一个0         | (101101->1011010)         | x shl 1
在最后加一个1         | (101101->1011011)         | x shl 1+1
把最后一位变成1       | (101100->101101)          | x or 1
把最后一位变成0       | (101101->101100)          | x or 1-1
最后一位取反          | (101101->101100)          | x xor 1
把右数第k位变成1      | (101001->101101,k=3)      | x or (1 shl (k-1))
把右数第k位变成0      | (101101->101001,k=3)      | x and not (1 shl (k-1))
右数第k位取反         | (101001->101101,k=3)      | x xor (1 shl (k-1))
取末三位              | (1101101->101)            | x and 7
取末k位               | (1101101->1101,k=5)       | x and (1 shl k-1)
取右数第k位           | (1101101->1,k=4)          | x shr (k-1) and 1
把末k位变成1          | (101001->101111,k=4)      | x or (1 shl k-1)
末k位取反             | (101001->100110,k=4)      | x xor (1 shl k-1)
把右边连续的1变成0    | (100101111->100100000)    | x and (x+1)
把右起第一个0变成1    | (100101111->100111111)    | x or (x+1)
把右边连续的0变成1    | (11011000->11011111)      | x or (x-1)
取右边连续的1         | (100101111->1111)         | (x xor (x+1)) shr 1
去掉右起第一个1的左边 | (100101000->1000)         | x and (x xor (x-1))

## 补码原码，和反码

这三者的基础知识，不再赘述。应当注意，补码和原码的知识在了解**数论中的同余知识**之后，便十分轻易地理解其中的一些规则，如补码等于原码取反加1；以及其本质的特征。

如果需要可以 refer: [原码、反码、补码的产生、应用以及优缺点有哪些？ - 知乎](https://www.zhihu.com/question/20159860)；[为什么-0的补码是00000000？ - Coldwings的回答 - 知乎](https://www.zhihu.com/question/21511392/answer/82989720)

## 取负

利用同余知识，补码和原码其实是同余关系：
- 原码 ≡ 补码 (MOD 2^N) , N 是位数
- 正数取反加1正好变成对应的负数（补码表示）
- 负数取反加1正好表成原码
```c
int a = INT_MIN;
unsigned int b = (unsigned int )(-a);   // 等价于 unsigned int b = (unsigned int )(~a+1); 
```
## 取绝对值

```c++
int abs(int x){
    return (x >> 31) == 0 ? x : (~x+1);
}
```
其中，`x>>31`是取出符号位，正数直接返回；负数，取反加1。

## 高低位互换

```c++
unsigned int a = INT_MIN;
a = (a >> 16) | (a<<16);
```

## 二进制逆序

~~~c++
unsigned short a = 34520;

a = ((a & 0xAAAA) >> 1) | ((a & 0x5555) << 1);
a = ((a & 0xCCCC) >> 2) | ((a & 0x3333) << 2);
a = ((a & 0xF0F0) >> 4) | ((a & 0x0F0F) << 4);
a = ((a & 0xFF00) >> 8) | ((a & 0x00FF) << 8);
~~~

## 是否是2的幂次


